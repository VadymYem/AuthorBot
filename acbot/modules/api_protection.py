
#              ¬© Copyright 2022
#           https://t.me/authorche
#
# üîí      Licensed under the GNU AGPLv3
# üåê https://www.gnu.org/licenses/agpl-3.0.html

import asyncio
import io
import json
import logging
import time

from telethon.tl.types import Message
from telethon.tl import functions
from telethon.tl.tlobject import TLRequest

from .. import loader, utils
from ..inline.types import InlineCall

logger = logging.getLogger(__name__)

GROUPS = [
    "auth",
    "account",
    "users",
    "contacts",
    "messages",
    "updates",
    "photos",
    "upload",
    "help",
    "channels",
    "bots",
    "payments",
    "stickers",
    "phone",
    "langpack",
    "folders",
    "stats",
]


def decapitalize(string: str) -> str:
    return string[0].lower() + string[1:]


CONSTRUCTORS = {
    decapitalize(
        method.__class__.__name__.rsplit("Request", 1)[0]
    ): method.CONSTRUCTOR_ID
    for method in utils.array_sum(
        [
            [
                method
                for method in dir(getattr(functions, group))
                if isinstance(method, TLRequest)
            ]
            for group in GROUPS
        ]
    )
}


@loader.tds
class APIRatelimiterMod(loader.Module):
    """Helps userbot avoid spamming Telegram API"""

    strings = {
        "name": "APILimiter",
        "warning": (
            "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji>"
            " <b>WARNING!</b>\n\nYour account exceeded the limit of requests, specified"
            " in config. In order to prevent Telegram API Flood, userbot has been"
            " <b>fully frozen</b> for {} seconds. Further info is provided in attached"
            " file. \n\nIt is recommended to get help in <code>{prefix}support</code>"
            " group!\n\nIf you think, that it is an intended behavior, then wait until"
            " userbot gets unlocked and next time, when you will be going to perform"
            " such an operation, use <code>{prefix}suspend_api_protect</code> &lt;time"
            " in seconds&gt;"
        ),
        "args_invalid": (
            "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji> <b>Invalid arguments</b>"
        ),
        "suspended_for": (
            "<emoji document_id=5458450833857322148>üëå</emoji> <b>API Flood Protection"
            " is disabled for {} seconds</b>"
        ),
        "test": (
            "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji> <b>This action will"
            " expose your account to flooding Telegram API.</b> <i>In order to confirm,"
            " that you really know, what you are doing, complete this simple test -"
            " find the emoji, differing from others</i>"
        ),
        "on": (
            "<emoji document_id=5458450833857322148>üëå</emoji> <b>Protection enabled</b>"
        ),
        "off": (
            "<emoji document_id=5458450833857322148>üëå</emoji> <b>Protection"
            " disabled</b>"
        ),
        "u_sure": (
            "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji> <b>Are you sure?</b>"
        ),
    }

    strings_ru = {
        "warning": (
            "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji>"
            " <b>–í–ù–ò–ú–ê–ù–ò–ï!</b>\n\n–ê–∫–∫–∞—É–Ω—Ç –≤—ã—à–µ–ª –∑–∞ –ª–∏–º–∏—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤, —É–∫–∞–∑–∞–Ω–Ω—ã–µ –≤"
            " –∫–æ–Ω—Ñ–∏–≥–µ. –° —Ü–µ–ª—å—é –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Ñ–ª—É–¥–∞ Telegram API, —é–∑–µ—Ä–±–æ—Ç –±—ã–ª"
            " <b>–ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–º–æ—Ä–æ–∂–µ–Ω</b> –Ω–∞ {} —Å–µ–∫—É–Ω–¥. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è"
            " –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–∞ –≤ —Ñ–∞–π–ª–µ –Ω–∏–∂–µ. \n\n–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∑–∞ –ø–æ–º–æ—â—å—é –≤"
            " <code>{prefix}support</code> –≥—Ä—É–ø–ø—É!\n\n–ï—Å–ª–∏ —Ç—ã —Å—á–∏—Ç–∞–µ—à—å, —á—Ç–æ —ç—Ç–æ"
            " –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ —é–∑–µ—Ä–±–æ—Ç–∞, –ø—Ä–æ—Å—Ç–æ –ø–æ–¥–æ–∂–¥–∏, –ø–æ–∫–∞ –∑–∞–∫–æ–Ω—á–∏—Ç—Å—è"
            " —Ç–∞–π–º–µ—Ä –∏ –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑, –∫–æ–≥–¥–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä—É–µ—à—å –≤—ã–ø–æ–ª–Ω—è—Ç—å —Ç–∞–∫—É—é"
            " —Ä–µ—Å—É—Ä—Å–æ–∑–∞—Ç—Ä–∞—Ç–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é, –∏—Å–ø–æ–ª—å–∑—É–π"
            " <code>{prefix}suspend_api_protect</code> &lt;–≤—Ä–µ–º—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö&gt;"
        ),
        "args_invalid": (
            "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji> <b>–ù–µ–≤–µ—Ä–Ω—ã–µ"
            " –∞—Ä–≥—É–º–µ–Ω—Ç—ã</b>"
        ),
        "suspended_for": (
            "<emoji document_id=5458450833857322148>üëå</emoji> <b>–ó–∞—â–∏—Ç–∞ API –æ—Ç–∫–ª—é—á–µ–Ω–∞"
            " –Ω–∞ {} —Å–µ–∫—É–Ω–¥</b>"
        ),
        "test": (
            "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji> <b>–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ"
            " –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —é–∑–µ—Ä–±–æ—Ç—É –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ñ–ª—É–¥–∏—Ç—å Telegram API.</b> <i>–î–ª—è —Ç–æ–≥–æ,"
            " —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ —Ç—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —É–≤–µ—Ä–µ–Ω –≤ —Ç–æ–º, —á—Ç–æ –¥–µ–ª–∞–µ—à—å - —Ä–µ—à–∏"
            " –ø—Ä–æ—Å—Ç–µ–Ω—å–∫–∏–π —Ç–µ—Å—Ç - –Ω–∞–π–¥–∏ –æ—Ç–ª–∏—á–∞—é—â–∏–π—Å—è —ç–º–æ–¥–∑–∏.</i>"
        ),
        "on": "<emoji document_id=5458450833857322148>üëå</emoji> <b>–ó–∞—â–∏—Ç–∞ –≤–∫–ª—é—á–µ–Ω–∞</b>",
        "off": (
            "<emoji document_id=5458450833857322148>üëå</emoji> <b>–ó–∞—â–∏—Ç–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞</b>"
        ),
        "u_sure": "<emoji document_id=6319093650693293883>‚ò£Ô∏è</emoji> <b>–¢—ã —É–≤–µ—Ä–µ–Ω?</b>",
    }

    _ratelimiter = []
    _suspend_until = 0
    _lock = False

    def __init__(self):
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "time_sample",
                15,
                lambda: "Time sample through which the bot will count requests",
                validator=loader.validators.Integer(minimum=1),
            ),
            loader.ConfigValue(
                "threshold",
                100,
                lambda: "Threshold of requests to trigger protection",
                validator=loader.validators.Integer(minimum=10),
            ),
            loader.ConfigValue(
                "local_floodwait",
                30,
                lambda: "Freeze userbot for this amount of time, if request limit exceeds",
                validator=loader.validators.Integer(minimum=10, maximum=3600),
            ),
            loader.ConfigValue(
                "forbidden_methods",
                ["joinChannel", "importChatInvite"],
                lambda: "Forbid specified methods from being executed throughout external modules",
                validator=loader.validators.MultiChoice(
                    [
                        "sendReaction",
                        "joinChannel",
                        "importChatInvite",
                    ]
                ),
                on_change=lambda: self._client.forbid_constructors(
                    map(
                        lambda x: CONSTRUCTORS[x], self.config["forbidden_constructors"]
                    )
                ),
            ),
        )

    async def client_ready(self):
        asyncio.ensure_future(self._install_protection())

    async def _install_protection(self):
        await asyncio.sleep(30)  # Restart lock
        if hasattr(self._client._call, "_old_call_rewritten"):
            raise loader.SelfUnload("Already installed")

        old_call = self._client._call

        async def new_call(
            sender: "MTProtoSender",  # type: ignore
            request: "TLRequest",  # type: ignore
            ordered: bool = False,
            flood_sleep_threshold: int = None,
        ):
            if time.perf_counter() > self._suspend_until and not self.get(
                "disable_protection",
                True,
            ):
                request_name = type(request).__name__
                self._ratelimiter += [[request_name, time.perf_counter()]]

                self._ratelimiter = list(
                    filter(
                        lambda x: time.perf_counter() - x[1]
                        < int(self.config["time_sample"]),
                        self._ratelimiter,
                    )
                )

                if (
                    len(self._ratelimiter) > int(self.config["threshold"])
                    and not self._lock
                ):
                    self._lock = True
                    report = io.BytesIO(
                        json.dumps(
                            self._ratelimiter,
                            indent=4,
                        ).encode("utf-8")
                    )
                    report.name = "local_fw_report.json"

                    await self.inline.bot.send_document(
                        self.tg_id,
                        report,
                        caption=self.strings("warning").format(
                            self.config["local_floodwait"],
                            prefix=self.get_prefix(),
                        ),
                    )

                    # It is intented to use time.sleep instead of asyncio.sleep
                    time.sleep(int(self.config["local_floodwait"]))
                    self._lock = False

            return await old_call(sender, request, ordered, flood_sleep_threshold)

        self._client._call = new_call
        self._client._old_call_rewritten = old_call
        self._client._call._acbot_overwritten = True
        logger.debug("Successfully installed ratelimiter")

    async def on_unload(self):
        if hasattr(self._client, "_old_call_rewritten"):
            self._client._call = self._client._old_call_rewritten
            delattr(self._client, "_old_call_rewritten")
            logger.debug("Successfully uninstalled ratelimiter")

    @loader.command(ru_doc="<–≤—Ä–µ–º—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö> - –ó–∞–º–æ—Ä–æ–∑–∏—Ç—å –∑–∞—â–∏—Ç—É API –Ω–∞ N —Å–µ–∫—É–Ω–¥")
    async def suspend_api_protect(self, message: Message):
        """<time in seconds> - Suspend API Ratelimiter for n seconds"""
        args = utils.get_args_raw(message)

        if not args or not args.isdigit():
            await utils.answer(message, self.strings("args_invalid"))
            return

        self._suspend_until = time.perf_counter() + int(args)
        await utils.answer(message, self.strings("suspended_for").format(args))

    @loader.command(ru_doc="–í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –∑–∞—â–∏—Ç—É API")
    async def api_fw_protection(self, message: Message):
        """Toggle API Ratelimiter"""
        await self.inline.form(
            message=message,
            text=self.strings("u_sure"),
            reply_markup=[
                {"text": "üö´ No", "action": "close"},
                {"text": "‚úÖ Yes", "callback": self._finish},
            ],
        )

    async def _finish(self, call: InlineCall):
        state = self.get("disable_protection", True)
        self.set("disable_protection", not state)
        await call.edit(self.strings("on" if state else "off"))
